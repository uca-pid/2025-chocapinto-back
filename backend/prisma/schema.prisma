generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ClubRole {
  OWNER     // Propietario/Fundador
  MODERADOR 
  LECTOR    
}
model User {
  id              Int               @id @default(autoincrement())
  username        String            @unique
  email           String?           @unique
  password        String
  role            String
  avatar          String?
  solicitudes     ClubSolicitud[]
  // clubs           Club[]            @relation("ClubMembers")
  memberships    ClubMember[]
  comments        Comment[]
  clubBooks       ClubBook[]        @relation("LibrosSubidos") // ← relación inversa a ClubBook.addedBy
  readingHistory  ReadingHistory[]
  votos           Voto[]            // Votos del usuario en períodos de lectura
  xp     Int @default(0)
  level  Int @default(1)
  resetTokens PasswordResetToken[]
  confirmacionesAsistencia ConfirmacionAsistencia[]
  asistenciasReales        AsistenciaReal[]
  notificaciones  Notificacion[] 

}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique // El código largo y secreto
  userId    Int      // A quién pertenece
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime // Cuándo deja de servir (ej: en 1 hora)
  createdAt DateTime @default(now())

  @@map("password_reset_tokens")
}


model ClubSolicitud {
  id        Int       @id @default(autoincrement())
  club      Club      @relation(fields: [clubId], references: [id])
  clubId    Int
  user      User      @relation(fields: [userId], references: [id])
  userId    Int
  estado    String    // "pendiente", "aceptada", "rechazada"
  createdAt DateTime  @default(now())
}

model Club {
  id              Int               @id @default(autoincrement())
  name            String
  description     String
  id_owner        Int               // Propietario del club
  imagen          String?
  solicitudes     ClubSolicitud[]
  // members         User[]            @relation("ClubMembers")
  memberships    ClubMember[]
  clubBooks       ClubBook[]
  readingHistory  ReadingHistory[]
  clubCategories ClubCategoria[] @relation("ClubToClubCategoria")
  periodosLectura PeriodoLectura[] // Períodos de lectura del club
  sesionesLectura  SesionLectura[]
}

model Book {
  id              Int               @id @default(autoincrement())
  title           String
  author          String?
  id_api          Int?
  portada         String?
  categorias      Categoria[]       @relation("BookCategorias")
  clubBooks       ClubBook[]
  readingHistory  ReadingHistory[]
}

model Categoria {
  id       Int      @id @default(autoincrement())
  nombre   String   @unique
  libros   Book[]   @relation("BookCategorias")
}

model Comment {
  id          Int        @id @default(autoincrement())
  content     String
  createdAt   DateTime   @default(now())
  user        User       @relation(fields: [userId], references: [id])
  userId      Int
  clubBook    ClubBook?   @relation(fields: [clubBookId], references: [id])
  clubBookId  Int?
}

model ClubBook {
  id          Int        @id @default(autoincrement())
  club        Club       @relation(fields: [clubId], references: [id])
  clubId      Int
  book        Book       @relation(fields: [bookId], references: [id])
  bookId      Int
  estado      String     // "pendiente", "en lectura", "leído", etc.
  addedAt     DateTime   @default(now())
  addedBy     User       @relation("LibrosSubidos", fields: [addedById], references: [id]) // relación con User
  addedById   Int
  comments    Comment[]  // comentarios sobre este libro en el club
  
  // Nuevas relaciones para períodos de lectura
  opcionesVotacion   VotacionOpcion[]
  periodoGanador     PeriodoLectura?  @relation("LibroGanador")
  sesionesLectura  SesionLectura[]

  @@unique([clubId, bookId])
}

model ReadingHistory {
  id           Int      @id @default(autoincrement())
  userId       Int
  bookId       Int
  clubId       Int
  estado       String   // "por_leer", "leyendo", "leido"
  fechaCambio  DateTime @default(now())
  fechaInicio  DateTime? // Cuando empezó a leer
  fechaFin     DateTime? // Cuando terminó de leer
  
  user         User     @relation(fields: [userId], references: [id])
  book         Book     @relation(fields: [bookId], references: [id])
  club         Club     @relation(fields: [clubId], references: [id])
  
  @@map("reading_history")
}

model ClubMember {
  id       Int      @id @default(autoincrement())
  user     User     @relation(fields: [userId], references: [id])
  userId   Int
  club     Club     @relation(fields: [clubId], references: [id])
  clubId   Int
  
  // Aquí se guarda el ROL del usuario EN ESTE club
  role     ClubRole @default(LECTOR) 
  
  joinedAt DateTime @default(now())

  @@unique([userId, clubId]) // Un usuario solo puede estar una vez en un club
  @@map("club_members")
}

model ClubCategoria {
  id     Int    @id @default(autoincrement())
  nombre String @unique
  clubs  Club[] @relation("ClubToClubCategoria") // Clubes que tienen esta categoría

  @@map("club_categorias")
}

// ========== NUEVO SISTEMA DE PERÍODOS DE LECTURA ==========

// Modelo para un "Ciclo de Lectura" o "Período"
model PeriodoLectura {
  id                 Int      @id @default(autoincrement())
  club               Club     @relation(fields: [clubId], references: [id])
  clubId             Int
  nombre             String   // Ej: "Lectura de Enero 2025"
  
  // Estados del período
  estado             String   // "VOTACION", "LEYENDO", "CERRADO"
  
  // Fechas importantes
  fechaFinVotacion   DateTime // La "cuenta regresiva" de la votación
  fechaFinLectura    DateTime // La fecha límite del período de lectura
  
  // Libro ganador (se asigna cuando termina la votación)
  libroGanador       ClubBook? @relation("LibroGanador", fields: [libroGanadorId], references: [id])
  libroGanadorId     Int?      @unique
  
  // Opciones de votación para este período
  opciones           VotacionOpcion[]
  
  // Timestamps
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  @@map("periodos_lectura")
}

// Libros propuestos para votar en un período
model VotacionOpcion {
  id        Int      @id @default(autoincrement())
  
  // Relación con el período
  periodo   PeriodoLectura @relation(fields: [periodoId], references: [id], onDelete: Cascade)
  periodoId Int
  
  // Se enlaza al ClubBook que está "por leer"
  clubBook  ClubBook @relation(fields: [clubBookId], references: [id])
  clubBookId  Int
  
  // Votos recibidos para esta opción
  votos     Voto[]
  
  // Un libro solo puede estar una vez en cada período
  @@unique([periodoId, clubBookId])
  @@map("votacion_opciones")
}

// Registra el voto de un usuario en una opción
model Voto {
  id        Int      @id @default(autoincrement())
  
  // La opción por la que votó
  opcion    VotacionOpcion @relation(fields: [opcionId], references: [id], onDelete: Cascade)
  opcionId  Int
  
  // El usuario que votó
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  
  // Timestamp del voto
  createdAt DateTime @default(now())
  
  // Un usuario solo puede votar una vez por opción
  @@unique([opcionId, userId])
  @@map("votos")
}

// ========== SISTEMA DE SESIONES DE LECTURA Y AGENDA ==========

// Sesiones de lectura programadas
model SesionLectura {
  id              Int      @id @default(autoincrement())
  
  // Club al que pertenece
  club            Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  clubId          Int
  
  // Libro asociado (opcional - puede ser una sesión general)
  clubBook        ClubBook? @relation(fields: [clubBookId], references: [id])
  clubBookId      Int?
  
  // Información de la sesión
  titulo          String   // Ej: "Debate capítulos 1-5"
  descripcion     String?  // Notas o consigna
  
  // Fecha y hora
  fechaHora       DateTime
  
  // Lugar (dirección física o link de videollamada)
  lugar           String
  
  // Estado de la sesión
  estado          String   @default("PROGRAMADA") // PROGRAMADA, COMPLETADA, CANCELADA
  
  // Confirmaciones de asistencia
  confirmaciones  ConfirmacionAsistencia[]
  
  // Registro de asistencia real
  asistencias     AsistenciaReal[]
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("sesiones_lectura")
}

// Confirmación de asistencia (antes del evento)
model ConfirmacionAsistencia {
  id        Int      @id @default(autoincrement())
  
  // Sesión a la que confirma
  sesion    SesionLectura @relation(fields: [sesionId], references: [id], onDelete: Cascade)
  sesionId  Int
  
  // Usuario que confirma
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  
  // Estado: "ASISTIRE", "NO_VOY", "TAL_VEZ"
  estado    String
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Un usuario solo puede confirmar una vez por sesión
  @@unique([sesionId, userId])
  @@map("confirmaciones_asistencia")
}

// Registro de asistencia real (después del evento)
model AsistenciaReal {
  id        Int      @id @default(autoincrement())
  
  // Sesión a la que asistió
  sesion    SesionLectura @relation(fields: [sesionId], references: [id], onDelete: Cascade)
  sesionId  Int
  
  // Usuario que asistió
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  
  // Timestamp del registro
  createdAt DateTime @default(now())
  
  // Un usuario solo puede registrarse una vez por sesión
  @@unique([sesionId, userId])
  @@map("asistencias_reales")
}



// ========== SISTEMA DE NOTIFICACIONES ==========

model Notificacion {
  id        Int      @id @default(autoincrement())
  
  // Usuario que recibe la notificación
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  
  // Tipo de notificación
  tipo      String   // "SESION_CREADA", "SESION_CANCELADA", "VOTACION_INICIADA", "LIBRO_AGREGADO", etc.
  
  // Título y mensaje
  titulo    String
  mensaje   String
  
  // Datos adicionales en formato JSON (para links, ids, etc)
  datos     String?  // JSON string: {clubId, sesionId, etc}
  
  // Estado de lectura
  leida     Boolean  @default(false)
  
  // Timestamps
  createdAt DateTime @default(now())
  
  @@map("notificaciones")
  @@index([userId, leida]) // Índice para consultas rápidas de notificaciones no leídas
}